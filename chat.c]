#include <stdio.h>
#include <string.h>
#include "mtk_c.h"

#define SCREEN_SEM 0
#define INPUT_SEM 1
#define MAX_NAME 16
#define MAX_MSG 256

/* ユーザー情報 */
typedef struct {
    char name[MAX_NAME];
    char color[8];
    char input_buffer[MAX_MSG];
    int input_pos;
    int is_typing;
} User;

User user1, user2;
int system_ready = 0;

/* 色コード定義 */
const char *colors[] = {
    "\x1b[31m", /* red */
    "\x1b[32m", /* green */
    "\x1b[33m", /* yellow */
    "\x1b[34m", /* blue */
    "\x1b[35m", /* magenta */
    "\x1b[36m", /* cyan */
    "\x1b[37m"  /* white */
};

void init_user(User *u, const char *default_name, const char *default_color) {
    strcpy(u->name, default_name);
    strcpy(u->color, default_color);
    u->input_buffer[0] = '\0';  /* バッファを空文字列に初期化 */
    u->input_pos = 0;            /* 入力位置を0に初期化 */
    u->is_typing = 0;            /* 入力中フラグをオフに初期化 */
}

void clear_input_line(FILE *fp) {
    fprintf(fp, "\r\x1b[2K");
}

void redraw_input(FILE *fp, User *u) {
    fprintf(fp, ">%s", u->input_buffer);
}

int total_messages_sent = 0;

void send_message(User *sender, const char *msg) {
    char buf[512];
    int pos = 0;
    
    /* 両方の画面の入力行を消去してからメッセージ表示 */
    pos += sprintf(buf + pos, "\r\x1b[2K");
    pos += sprintf(buf + pos, "%s%s: \x1b[0m%s\n", sender->color, sender->name, msg);
    
    /* 一度に出力 */
    fprintf(com0out, "%s", buf);
    fprintf(com1out, "%s", buf);
    
    /* プロンプトを再表示（入力中だった場合は入力内容も） */
    if (user1.is_typing) {
        redraw_input(com0out, &user1);
    } else {
        fprintf(com0out, ">");
    }
    
    if (user2.is_typing) {
        redraw_input(com1out, &user2);
    } else {
        fprintf(com1out, ">");
    }
    
    total_messages_sent++;
}

void handle_command(User *u, FILE *out_fp, const char *cmd) {
    if (strncmp(cmd, "/name ", 6) == 0) {
        P(SCREEN_SEM);
        strncpy(u->name, cmd + 6, MAX_NAME - 1);
        u->name[MAX_NAME - 1] = '\0';
        
        char buf[128];
        sprintf(buf, "\r\x1b[2K\x1b[33m[System] Name changed to: %s\x1b[0m\n>", u->name);
        fprintf(out_fp, "%s", buf);
        V(SCREEN_SEM);
    }
    else if (strncmp(cmd, "/color ", 7) == 0) {
        const char *color_name = cmd + 7;
        int found = 0;
        
        P(SCREEN_SEM);
        if (strcmp(color_name, "red") == 0) {
            strcpy(u->color, colors[0]);
            found = 1;
        } else if (strcmp(color_name, "green") == 0) {
            strcpy(u->color, colors[1]);
            found = 1;
        } else if (strcmp(color_name, "yellow") == 0) {
            strcpy(u->color, colors[2]);
            found = 1;
        } else if (strcmp(color_name, "blue") == 0) {
            strcpy(u->color, colors[3]);
            found = 1;
        } else if (strcmp(color_name, "magenta") == 0) {
            strcpy(u->color, colors[4]);
            found = 1;
        } else if (strcmp(color_name, "cyan") == 0) {
            strcpy(u->color, colors[5]);
            found = 1;
        } else if (strcmp(color_name, "white") == 0) {
            strcpy(u->color, colors[6]);
            found = 1;
        }
        
        if (found) {
            char buf[128];
            sprintf(buf, "\r\x1b[2K\x1b[33m[System] Color changed to: %s\x1b[0m\n>", color_name);
            fprintf(out_fp, "%s", buf);
        } else {
            fprintf(out_fp, "\r\x1b[2K\x1b[33m[System] Unknown color. Available: red, green, yellow, blue, magenta, cyan, white\x1b[0m\n>");
        }
        V(SCREEN_SEM);
    }
    else if (strcmp(cmd, "/help") == 0) {
        P(SCREEN_SEM);
        fprintf(out_fp, "\r\x1b[2K\x1b[33m[System] Commands:\x1b[0m\n");
        fprintf(out_fp, "  /name <name> - Change your name\n");
        fprintf(out_fp, "  /color <color> - Change your color\n");
        fprintf(out_fp, "  /help - Show this help\n>");
        V(SCREEN_SEM);
    }
    else {
        P(SCREEN_SEM);
        fprintf(out_fp, "\r\x1b[2K\x1b[33m[System] Unknown command. Type /help for commands\x1b[0m\n>");
        V(SCREEN_SEM);
    }
}

/* タスク1: ユーザー1の入力処理 */
void task1() {
    char input_char;
    
    fprintf(com0out, "\x1b[2J\x1b[H");
    fprintf(com0out, "\x1b[33m=== CHAT SYSTEM ===\x1b[0m\n");
    fprintf(com0out, "\x1b[33mEnter your name > \x1b[0m");
    
    /* 名前入力 */
    int name_idx = 0;
    while (1) {
        input_char = fgetc(com0in);
        if (input_char == '\n' || input_char == '\r') {
            user1.name[name_idx] = '\0';
            break;
        } else if (input_char == '\x7f' || input_char == '\x08') {
            if (name_idx > 0) {
                name_idx--;
                fprintf(com0out, "\x08 \x08");
            }
        } else if (input_char >= 32 && input_char <= 126 && name_idx < MAX_NAME - 1) {
            user1.name[name_idx++] = input_char;
            fprintf(com0out, "%c", input_char);
        }
    }
    
    fprintf(com0out, "\x1b[33mWelcome, %s!\x1b[0m\n", user1.name);
    fprintf(com0out, "Type /help for commands\n>");
    
    system_ready = 1;
    
    while (1) {
        input_char = fgetc(com0in);
        
        P(INPUT_SEM);
        
        if (input_char == '\n' || input_char == '\r') {
            if (user1.input_pos > 0) {
                user1.input_buffer[user1.input_pos] = '\0';
                user1.is_typing = 0;
                
                if (user1.input_buffer[0] == '/') {
                    /* コマンド実行（自分の画面のみ消去） */
                    P(SCREEN_SEM);
                    fprintf(com0out, "\r\x1b[2K");
                    V(SCREEN_SEM);
                    handle_command(&user1, com0out, user1.input_buffer);
                } else {
                    /* メッセージ送信（send_message内で両画面消去） */
                    P(SCREEN_SEM);
                    send_message(&user1, user1.input_buffer);
                    V(SCREEN_SEM);
                }
                
                user1.input_pos = 0;
                user1.input_buffer[0] = '\0';
            } else {
                /* 空行の場合はプロンプトだけ再表示 */
                P(SCREEN_SEM);
                fprintf(com0out, "\r\x1b[2K>");
                V(SCREEN_SEM);
            }
        } else if (input_char == '\x7f' || input_char == '\x08') {
            if (user1.input_pos > 0) {
                user1.input_pos--;
                user1.input_buffer[user1.input_pos] = '\0';
                P(SCREEN_SEM);
                fprintf(com0out, "\x08 \x08");
                V(SCREEN_SEM);
            }
        } else if (input_char >= 32 && input_char <= 126) {
            /* 印字可能文字（スペース含む）のみ受け付け */
            if (user1.input_pos < MAX_MSG - 1) {
                user1.input_buffer[user1.input_pos++] = input_char;
                user1.input_buffer[user1.input_pos] = '\0';
                user1.is_typing = 1;
                P(SCREEN_SEM);
                fprintf(com0out, "%c", input_char);
                V(SCREEN_SEM);
            }
        }
        
        V(INPUT_SEM);
    }
}

/* タスク2: ユーザー2の入力処理 */
void task2() {
    char input_char;
    
    /* system_readyを待つ（待機時間を短く） */
    while (!system_ready) {
        for (int i = 0; i < 10000; i++);
    }
    
    fprintf(com1out, "\x1b[2J\x1b[H");
    fprintf(com1out, "\x1b[33m=== CHAT SYSTEM ===\x1b[0m\n");
    fprintf(com1out, "\x1b[33mEnter your name > \x1b[0m");
    
    /* 名前入力 */
    int name_idx = 0;
    while (1) {
        input_char = fgetc(com1in);
        if (input_char == '\n' || input_char == '\r') {
            user2.name[name_idx] = '\0';
            break;
        } else if (input_char == '\x7f' || input_char == '\x08') {
            if (name_idx > 0) {
                name_idx--;
                fprintf(com1out, "\x08 \x08");
            }
        } else if (input_char >= 32 && input_char <= 126 && name_idx < MAX_NAME - 1) {
            user2.name[name_idx++] = input_char;
            fprintf(com1out, "%c", input_char);
        }
    }
    
    fprintf(com1out, "\x1b[33mWelcome, %s!\x1b[0m\n", user2.name);
    fprintf(com1out, "Type /help for commands\n>");
    
    while (1) {
        input_char = fgetc(com1in);
        
        P(INPUT_SEM);
        
        if (input_char == '\n' || input_char == '\r') {
            if (user2.input_pos > 0) {
                user2.input_buffer[user2.input_pos] = '\0';
                user2.is_typing = 0;
                
                if (user2.input_buffer[0] == '/') {
                    /* コマンド実行（自分の画面のみ消去） */
                    P(SCREEN_SEM);
                    fprintf(com1out, "\r\x1b[2K");
                    V(SCREEN_SEM);
                    handle_command(&user2, com1out, user2.input_buffer);
                } else {
                    /* メッセージ送信（send_message内で両画面消去） */
                    P(SCREEN_SEM);
                    send_message(&user2, user2.input_buffer);
                    V(SCREEN_SEM);
                }
                
                user2.input_pos = 0;
                user2.input_buffer[0] = '\0';
            } else {
                /* 空行の場合はプロンプトだけ再表示 */
                P(SCREEN_SEM);
                fprintf(com1out, "\r\x1b[2K>");
                V(SCREEN_SEM);
            }
        } else if (input_char == '\x7f' || input_char == '\x08') {
            if (user2.input_pos > 0) {
                user2.input_pos--;
                user2.input_buffer[user2.input_pos] = '\0';
                P(SCREEN_SEM);
                fprintf(com1out, "\x08 \x08");
                V(SCREEN_SEM);
            }
        } else if (input_char >= 32 && input_char <= 126) {
            /* 印字可能文字（スペース含む）のみ受け付け */
            if (user2.input_pos < MAX_MSG - 1) {
                user2.input_buffer[user2.input_pos++] = input_char;
                user2.input_buffer[user2.input_pos] = '\0';
                user2.is_typing = 1;
                P(SCREEN_SEM);
                fprintf(com1out, "%c", input_char);
                V(SCREEN_SEM);
            }
        }
        
        V(INPUT_SEM);
    }
}

/* タスク3: 入力状態監視・再描画タスク */
void task3() {
    int prev_typing1 = 0;
    int prev_typing2 = 0;
    
    while (1) {
        for (int i = 0; i < 500000; i++);
        
        P(INPUT_SEM);
        
        /* 入力状態が変化したら再描画 */
        if (prev_typing1 != user1.is_typing || prev_typing2 != user2.is_typing) {
            prev_typing1 = user1.is_typing;
            prev_typing2 = user2.is_typing;
        }
        
        V(INPUT_SEM);
    }
}

/* タスク4: システムメッセージ管理 */
void task4() {
    int cycle_count = 0;
    int last_total_messages = 0;
    int idle_count = 0;
    int milestone_10 = 0;
    int milestone_50 = 0;
    int milestone_100 = 0;
    
    /* 起動メッセージ */
    for (int i = 0; i < 2000000; i++);
    
    P(SCREEN_SEM);
    char buf[256];
    sprintf(buf, "\r\x1b[2K\x1b[96m[System] Chat session started. Type /help for commands.\x1b[0m\n>");
    fprintf(com0out, "%s", buf);
    fprintf(com1out, "%s", buf);
    V(SCREEN_SEM);
    
    while (1) {
        for (int i = 0; i < 3000000; i++);
        
        cycle_count++;
        
        P(INPUT_SEM);
        int current_total = total_messages_sent;
        int user1_typing = user1.is_typing;
        int user2_typing = user2.is_typing;
        V(INPUT_SEM);
        
        /* メッセージ数のマイルストーン通知 */
        if (current_total >= 10 && !milestone_10) {
            milestone_10 = 1;
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[96m[System] 10 messages! Conversation is flowing nicely.\x1b[0m\n");
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
        }
        
        if (current_total >= 50 && !milestone_50) {
            milestone_50 = 1;
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[96m[System] 50 messages exchanged! You're chatting a lot!\x1b[0m\n");
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
        }
        
        if (current_total >= 100 && !milestone_100) {
            milestone_100 = 1;
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[93m[System] AMAZING! 100 messages reached! \x1b[0m\n");
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
        }
        
        /* アイドル状態の検出（メッセージが増えていない） */
        if (current_total == last_total_messages) {
            idle_count++;
        } else {
            idle_count = 0;
        }
        last_total_messages = current_total;
        
        /* 20サイクル（約60秒）無活動で通知 */
        if (idle_count == 20) {
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[90m[System] Still there? Say hello!\x1b[0m\n");
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
        }
        
        /* 40サイクル（約120秒）無活動で統計表示 */
        if (idle_count == 40) {
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[90m[System] Session statistics: %d messages sent.\x1b[0m\n", current_total);
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
            
            idle_count = 0;
        }
        
        /* 30サイクルごとに接続確認メッセージ */
        if (cycle_count % 30 == 0 && current_total > 5) {
            P(SCREEN_SEM);
            sprintf(buf, "\r\x1b[2K\x1b[90m[System] Connection stable. %d messages so far.\x1b[0m\n", current_total);
            fprintf(com0out, "%s", buf);
            fprintf(com1out, "%s", buf);
            
            if (user1_typing) redraw_input(com0out, &user1);
            else fprintf(com0out, ">");
            if (user2_typing) redraw_input(com1out, &user2);
            else fprintf(com1out, ">");
            V(SCREEN_SEM);
        }
    }
}

int main() {
    printf("CHAT SYSTEM INITIALIZING\n");
    
    fd_mapping();
    printf("[OK] fd_mapping\n");
    
    init_kernel();
    printf("[OK] init_kernel\n");
    
    /* セマフォの初期化 */
    semaphore[SCREEN_SEM].count = 1;
    semaphore[SCREEN_SEM].nst = 0;
    semaphore[INPUT_SEM].count = 1;
    semaphore[INPUT_SEM].nst = 0;
    
    /* ユーザー初期化 */
    init_user(&user1, "User1", colors[1]); /* green */
    init_user(&user2, "User2", colors[0]); /* red */
    
    printf("[OK] Users initialized\n");
    
    set_task(task1);
    set_task(task2);
    set_task(task3);
    set_task(task4);
    
    printf("[OK] All tasks set\n");
    
    begin_sch();
    
    return 0;
}
